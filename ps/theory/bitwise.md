---
layout: page
tags: [problem-solving, theory, bitwise]
title: Bitwise Property
last_update: 2023-04-07 17:27:26
---

# Bitwise Property

## 노트
 - `XOR` 연산은 `<>`와 동치이다. 즉, 두 비트가 다르면 참을 반환한다.
 - 비트마스크 연산자 우선순위는 가장 낮기 때문에, 중첩된 연산 식에 쓰일 때에는
   항상 괄호를 쳐주자.
 - C++에서 1은 **부호있는 32비트 상수**로 취급되므로, 부호없는 64비트 1을 쓰고
   싶다면 항상 `1ull`의 형태로 쓰자.
 - 32비트 또는 64비트 *전체* 비트를 쓰고 싶다면 항상 **부호없는(unsigned)**
   정수를 쓰자. 음수를 잘못 쉬프트 하면 1이 채워질 수 있다.

## 2의 배수 알아내기

 2의 보수 성질에 의해 다음 등식이 성립한다: x = ~x + 1

 예를 들어 x = 7 이고 8비트만 살펴보면 다음과 같다.

```python
 0  0  0  0  0  1  1  1      x = 7
 1  1  1  1  1  0  0  0      ~x
 1  1  1  1  1  0  0  1      ~x + 1 == -x
```

 따라서 `x + (~x + 1)`을 계산해보면 모든 1이 사라지고 전부 0이
 된다. 그러므로 `~x + 1 == -x`이다.

 바이너리 표현에서 2의 보수에 의한 x와 -x의 관계를 알았으니 이 두 수를
 가지고 할 수 있는 것 중 하나를 살펴보자. 바로 x에서 가장 오른쪽에
 있는 1의 위치를 알아내는 방법이다.

```python
x = 7
 0  0  0  0  0  1  1  1      x
 1  1  1  1  1  0  0  1      -x
 0  0  0  0  0  0  0  1      x & -x

x = 6
 0  0  0  0  0  1  1  0      x
 1  1  1  1  1  0  1  0      -x
 0  0  0  0  0  0  1  0      x & -x
```

 즉, `x & -x`를 하면 가장 오른쪽에 있는 1 하나(바로 이게 2의 보수
 표현을 위해서 더해진 1)만 남기고 다 Unset 된다.

 이제 2의 배수인 경우에 이 연산이 어떻게 동작하는지 살펴보자. 예를
 들어 x = 16인 경우는 다음과 같다.

```python
x = 16
 0  0  0  1  0  0  0  0      x
 1  1  1  0  0  0  0  1      -x
 0  0  0  1  0  0  0  0      x & -x
```

 결과를 보면 2의 배수인 경우 `x & -x == x` 임을 알 수 있다. 이는
 생각해보면 매우 당연한 일이다.
 - 바이너리로 표현된 2의 배수는 딱 하나의 비트만 1이다.
 - `x & -x`는 가장 오른쪽에 있는 1 하나만 남긴다.
 - 그러므로 2의 배수는 가장 오른쪽에 있는 1 하나만 남긴 수와 같다.

 요약하면, `x & -x`는 가장 오른쪽에 있는 1인 비트 하나만을 **남기는**
 연산이고 이를 이용해서 2의 배수를 판별할 수 있다.

---

 이와 듀얼인 연산을 이용하는 다른 접근 방법도 있다. 즉 가장 오른쪽에
 있는 1인 비트를 *남기는*게 아니라, **지워버리는** 방법이다.

 먼저 x와 x-1의 관계를 살펴보자.

```python
x = 7
 0  0  0  0  0  1  1  1      x
 0  0  0  0  0  1  1  0      x - 1
 0  0  0  0  0  1  1  0      x & (x - 1)

x = 6
 0  0  0  0  0  1  1  0      x
 0  0  0  0  0  1  0  1      x - 1
 0  0  0  0  0  1  0  0      x & (x - 1)
```

즉, `x & (x - 1)`은 가장 오른쪽에 있는 1인 비트 하나만을 **지우는**
연산이다. 1을 빼는 것과는 다르다는 것에 주의하자.

이제 마찬가지로 2의 배수인 경우에 이 연산이 어떻게 동작하는지
살펴보자.

```python
x = 16
 0  0  0  1  0  0  0  0      x
 0  0  0  0  1  1  1  1      x - 1
 0  0  0  0  0  0  0  0      x & (x - 1)
```

 결과를 보면 2의 배수인 경우 `x & (x - 1) == 0`임을 알 수 있다. `x &
 (x - 1)` 연산이 가장 오른쪽의 1을 지워버리기 때문에, 이는 역시 매우
 당연한 일이다.

 따라서 두 가지 비트 연산을 통해 어떤 수가 2의 배수인지 아닌지를
 빠르게 판변할 수 있다.
 - `x & -x == x`
 - `x & (x - 1) == 0`
