#+title: Bitwise Property
#+last_update: 2023-04-10 12:33:26
#+layout: page
#+tags: problem-solving theory bitwise cpp

* Bitwise Property

 * 비스마스크 연산은 O(1) 구현이 많아서 적절히 사용하면 훨씬 빠르다.
 * 특히 집합 연산의 경우 반복문 없이 곧바로 가능한 경우가 많아서 코드가
   짧아진다.
 * 같은 데이터를 더 적은 메모리에 표현 가능하다. 따라서 더 많은 데이터를 미리
   계산해둘 수 있고, 캐시 효율도 좋아지며, 더 빨라질 수 있다.
 * ~XOR~ 연산은 =<>= 와 동치. 즉, 두 비트가 다르면 참을 반환한다.
 * 비트마스크 연산자 우선순위는 가장 낮기 때문에, 중첩된 연산 식에 쓰일 때에는
   항상 괄호를 쳐주자.
 * C++에서 1은 *부호있는 32비트 상수* 로 취급되므로, 부호없는 64비트 1을 쓰고
   싶다면 항상 =1ull=의 형태로 쓰자.
 * 32비트 또는 64비트 *전체* 비트를 쓰고 싶다면 항상 *부호없는(unsigned)* 정수를
   쓰자. 음수를 잘못 쉬프트 하면 1이 채워질 수 있다.


** 2의 제곱수 판별 (1)

2의 보수 표현에서 다음 등식이 성립한다: -=x = ~x + 1=

예를 들어 x = 7 인 경우를 살펴보면 다음과 같다.

#+begin_src c++
x = 7;
0 0 0 0 0 1 1 1  // x
1 1 1 1 1 0 0 0  // ~x
1 1 1 1 1 0 0 1  // ~x + 1 == -x
#+end_src

직접 =x + (~x + 1)= 을 계산해보면 전부 0이 된다는 것을 알 수 있다. 즉, 2의 보수
표현에서 =-x = ~x + 1= 이다.

이제 이 성질을 가지고 다음과 같이 =x= 의 *가장 오른쪽에 있는 1인 비트* 의 위치를
알아낼 수 있다.

#+begin_src c++
x = 7;
0 0 0 0 0 1 1 1  // x
1 1 1 1 1 0 0 1  // -x
0 0 0 0 0 0 0 1  // x & -x

x = 6;
0 0 0 0 0 1 1 0  // x
1 1 1 1 1 0 1 0  // -x
0 0 0 0 0 0 1 0  // x & -x
#+end_src

즉, 두 수를 AND 연산으로 묶으면 가장 오른쪽에 있는 1인 비트 하나만 남기고 다
Unset 된다.

=x= 가 2의 제곱수인 경우에 어떻게 되는지 보자.

#+begin_src c++
x = 16;
0 0 0 1 0 0 0 0  // x
1 1 1 1 0 0 0 0  // -x
0 0 0 1 0 0 0 0  // x & -x
#+end_src

=x= 가 2의 제곱수인 경우 (즉 =x = 2**x= 꼴) 위와 같이 =x & -x = x= 가 됨을 알 수 있다.

** 2의 제곱수 판별 (2)

첫 번째 방법이 가장 오른쪽에 있는 1인 비트만 /남기는/ 방법이었다면, 이와 반대로
가장 오른쪽에 있는 1인 비트를 딱 하나만 *지워버리는* 방법도 있다.

먼저 =x= 와 =x - 1= 의 비트 표현을 살펴보자.

#+begin_src c++
x = 7;
0 0 0 0 0 1 1 1  // x
0 0 0 0 0 1 1 0  // x - 1
0 0 0 0 0 1 1 0  // x & (x - 1)

x = 16;
0 0 0 1 0 0 0 0  // x
0 0 0 0 1 1 1 1  // x - 1
0 0 0 0 0 0 0 0  // x & (x - 1)
#+end_src

즉, =x= 가 2의 제곱수라면 =x & (x - 1) = 0= 이 됨을 알 수 있다.

**
